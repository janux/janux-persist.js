/**
 * Project glarus-services
 * Created by ernesto on 10/27/17.
 */
import Promise = require("bluebird");
import {PartyAbstract} from "janux-people";
import {OrganizationImpl} from "janux-people/dist/impl/Organization";
import {PersonImpl} from "janux-people/dist/impl/Person";
import * as _ from 'lodash';
import {ValidationErrorImpl} from "persistence/implementations/dao/validation-error";
import {GroupImpl} from "services/group-module/impl/group";
import {GroupPropertiesImpl} from "services/group-module/impl/group-properties";
import {GroupServiceImpl} from "services/group-module/impl/group-service";
import {GroupServiceValidator} from "services/group-module/impl/group-service-validator";
import {PartyGroupService} from "services/party-group-service/api/party-group-service";
import {InternalPartyGroupItem} from "services/party-group-service/impl/group-item-internal";
import {PartyGroupItemImpl} from "services/party-group-service/impl/party-group-item-impl";
import {PartyServiceImpl} from "services/party/impl/party-service-impl";
import * as logger from "utils/logger-api/logger-api";

export class PartyGroupServiceImpl implements PartyGroupService {

	// Don't change this value. This values is inserted in the database and used in queries.
	public static readonly ATTRIBUTE_PARTY_SERVICE_SIGNATURE = "____service";

	// Don't change this value. This values is inserted in the database and used in queries.
	public static readonly ATTRIBUTE_VALUE_PARTY_SERVICE_SIGNATURE = "PartyGroupServiceImpl";

	// Don't change this value. This values is inserted in the database and used in queries.
	public static readonly ATTRIBUTE_PARTY_ID: string = '____partyOwnerId';

	public static readonly ATTRIBUTE_VALUE_PARTY_SERVICE_SIGNATURE_INVALID = "The attribute that identifies the group as generated by the service is invalid or modified";
	public static readonly PARTY_OWNER: string = "partyOwner";
	public static readonly PARTY_ITEM: string = "partyOwner";
	public static readonly PARTY_ITEM_DUPLICATED: string = "The group contain duplicated party items";
	public static readonly PARTY_OWNER_DOES_NOT_EXIST = 'There is no party given the id';
	public static readonly PARTY_OWNER_DUPLICATED_GROUP = 'There is another party group with the same party owner and the same type';
	public static readonly PARTY_ITEM_DOES_NOT_EXIST: string = "Some party items does not exist in the database";
	public static readonly TYPE: string = "type";
	public static readonly ATTRIBUTE_CHANGE: string = "You can't change the attribute value";

	public static fromJSON(object: any): GroupImpl<PartyGroupItemImpl> {
		if (object == null) return object;
		const result: GroupImpl<PartyGroupItemImpl> = new GroupImpl<PartyGroupItemImpl>();
		result.name = object.name;
		result.attributes = object.attributes;
		result.type = object.type;
		result.code = object.code;
		result.description = object.description;
		result.values = _.map(object.values, (it: any) => this.fromJSONItem(it));
		return result;
	}

	public static fromJSONItem(object: any): PartyGroupItemImpl {
		if (object == null) return object;
		const result: PartyGroupItemImpl = new PartyGroupItemImpl();
		result.attributes = object.attributes;
		result.party = PartyServiceImpl.fromJSON(object.party);
		return result;
	}

	private partyService: PartyServiceImpl;
	private groupService: GroupServiceImpl<InternalPartyGroupItem>;
	private log = logger.getLogger("PartyGroupServiceImpl");

	constructor(partyService: PartyServiceImpl, groupService: GroupServiceImpl<InternalPartyGroupItem>) {
		this.partyService = partyService;
		this.groupService = groupService;
	}

	/**
	 * Find all groups ( no content ) given a type.
	 * @param {string} type
	 * @return {Bluebird<GroupPropertiesImpl[]>}
	 */
	findPropertiesByType(type: string): Promise<GroupPropertiesImpl[]> {
		this.log.debug("Call to findPropertiesByType with type: %j  " + type);
		return this.groupService.findPropertiesByType(type);
	}

	/**
	 * Find all group where the party is the owner fo the groups.
	 * @param {string[]} types The group types to look for.
	 * @param {PartyAbstract} partyId The party to look for.
	 * @return {Promise<GroupPropertiesImpl[]>} The groups where the party is associated.
	 */
	findPropertiesOwnedByPartyAndTypes(partyId: string, types: string[]): Promise<GroupPropertiesImpl[]> {
		this.log.debug("Call to findPropertiesOwnedByPartyAndTypes with types %j and party %j", types, partyId);
		return this.groupService.findPropertiesByTypes(types)
			.then((resultQuery: GroupPropertiesImpl[]) => {
				const filteredGroup = resultQuery.filter((value) => value.attributes[PartyGroupServiceImpl.ATTRIBUTE_PARTY_ID] === partyId);
				return Promise.resolve(filteredGroup);
			});
	}

	/**
	 * Find one group
	 * @param {string} code the group code.
	 * @return {Promise<GroupImpl<PartyAbstract>>}
	 */
	findOne(code: string): Promise<GroupImpl<PartyGroupItemImpl>> {
		this.log.debug("Call to find one with code: %j", code);
		let resultGroup: GroupImpl<any>;
		let referenceGroup: GroupImpl<InternalPartyGroupItem>;
		return this.groupService.findOne(code)
			.then((result: GroupImpl<InternalPartyGroupItem>) => {
				if (result == null) return Promise.resolve(null);
				referenceGroup = result;
				const ids = _.uniq(result.values.map((value) => value.partyId));
				return this.partyService.findByIds(ids)
					.then((result: PartyAbstract[]) => {
						resultGroup = _.clone(referenceGroup);
						resultGroup.values = referenceGroup.values.map((value) => {
							const item: PartyGroupItemImpl = new PartyGroupItemImpl();
							item.party = _.find(result, (o) => o['id'] === value.partyId);
							item.attributes = value.attributes;
							return item;
						});
						return Promise.resolve(resultGroup);
					});
			});
	}

	/**
	 * Find one group given the type and the owner of the group.
	 * @param {string} partyId partyId The owner of the group.
	 * @param {string} type type The type too look for.
	 * @param createOne If there is no group and this value is true, then this method inserts the missing group.
	 * @return {Promise<GroupImpl<PartyAbstract>>} Returns the group or null if there is no group given
	 * the conditions.
	 */
	findOneOwnedByPartyAndType(partyId: string, type: string, createOne ?: boolean): Promise<GroupImpl<PartyGroupItemImpl>> {
		this.log.debug("Call to findOneOwnedByPartyAndType by partyId %j, type  %j", partyId, type);
		const filter: {} = {};
		filter[PartyGroupServiceImpl.ATTRIBUTE_PARTY_ID] = partyId;
		return this.groupService.findByTypeAndFilter(type, filter)
			.then((result: Array<GroupImpl<InternalPartyGroupItem>>) => {
				if (result.length > 1) {
					this.log.error("There is more that one party group with the same type and party id \n %j", result);
					// Maybe consider throwing an error.
					return this.findOne(result[0].code);
				} else if (result.length === 0) {
					if (createOne === true) {
						// Create a new group.
						return this.partyService.findOne(partyId)
							.then((result: PartyAbstract) => {
								const groupToInsert: GroupImpl<PartyGroupItemImpl> = new GroupImpl();
								if (result.typeName === 'PersonImpl') {
									groupToInsert.name = (result as PersonImpl).name.first + (result as PersonImpl).name.last + " " + type + " group";
								} else {
									groupToInsert.name = (result as OrganizationImpl).name + " " + type + " group";
								}
								groupToInsert.description = groupToInsert.name + ". Group created by system request";
								groupToInsert.code = groupToInsert.name + " " + new Date().getTime();
								groupToInsert.type = type;

								return this.insert(partyId, groupToInsert);

							});
					} else {
						return Promise.resolve(null);
					}
				} else {
					return this.findOne(result[0].code);
				}
			});
	}

	/**
	 * Return all groups (including content) of all groups of a given types.
	 * @param {string[]} types
	 * @return {Promise<Array<GroupImpl<PartyAbstract>>>}
	 */
	findByTypes(types: string[]): Promise<Array<GroupImpl<PartyGroupItemImpl>>> {
		this.log.debug("Call to findByTypes with types: %j", types);
		return this.groupService.findAllByTypes(types)
			.then((result: Array<GroupImpl<InternalPartyGroupItem>>) => {
				return this.mapData(result);
				/*referenceGroups = result;
				let ids: string[] = [];
				for (const group of result) {
					ids = ids.concat(group.values.map(value => value.partyId));
				}
				ids = _.uniq(ids);
				return this.partyService.findByIds(ids)
					.then((resultQuery: PartyAbstract[]) => {
						let resultGroup: any[];
						resultGroup = referenceGroups.map(value => {
							const item: any = value;
							item.values = value.values.map(value2 => {
								const item2: PartyGroupItemImpl = new PartyGroupItemImpl();
								item2.party = _.find(resultQuery, (o) => o['id'] === value2.partyId);
								item2.attributes = value.attributes;
								return item2;
							});
							return item;
						});
						return Promise.resolve(resultGroup);
					});*/
			});

	}

	/**
	 * Find all group where the partyId belongs to.
	 * @param {string} type Th
	 * @param {string} partyIdItem
	 * @return {Bluebird<Array<Group<PartyGroupItem>>>}
	 */
	findByTypeAndPartyItem(type: string, partyIdItem: string): Promise<Array<GroupImpl<PartyGroupItemImpl>>> {
		return this.groupService.findByTypesAndItemByEmbeddedDocument(type, "partyId", partyIdItem)
			.then((result: Array<GroupImpl<InternalPartyGroupItem>>) => {
				return this.mapData(result);
			});
	}

	/**
	 * Inserts a new group.
	 * @param partyId Owner of the group. This variables in inserted as an group attribute.
	 * @param {GroupImpl} group to insert.
	 * @return {Promise<GroupImpl>} Returns a Promise if the object was inserted correctly.
	 * Returns a reject if there is another group with the same code.
	 * Returns a reject if the content of the groups has duplicated values or any of the parties does not exists in the database.
	 * Returns a reject if the owner does not exist in the database.
	 * Returns a reject if there is a party group with the same owner and type, but different code.
	 */
	insert(partyId: string, group: GroupImpl<PartyGroupItemImpl>): Promise<GroupImpl<PartyGroupItemImpl>> {
		this.log.debug("Call to insert with group: %j", group);

		const errors: ValidationErrorImpl[] = this.validatePartyGroup(group);
		if (errors.length > 0) return Promise.reject(errors);
		const newGroup: GroupImpl<any> = _.clone(group);
		const contactIds = group.values.map((value) => value.party['id']);
		newGroup.values = group.values.map(value => {
			const item: InternalPartyGroupItem = new InternalPartyGroupItem();
			item.partyId = value.party['id'];
			item.attributes = value.attributes;
			return item;
		});
		if (newGroup.attributes == null) {
			newGroup.attributes = {};
		}
		newGroup.attributes[PartyGroupServiceImpl.ATTRIBUTE_PARTY_ID] = partyId;
		newGroup.attributes[PartyGroupServiceImpl.ATTRIBUTE_PARTY_SERVICE_SIGNATURE] = PartyGroupServiceImpl.ATTRIBUTE_VALUE_PARTY_SERVICE_SIGNATURE;
		return this.partyService.findOne(partyId)
			.then((result) => {
				if (result == null) {
					return Promise.reject([new ValidationErrorImpl(
						PartyGroupServiceImpl.PARTY_OWNER,
						PartyGroupServiceImpl.PARTY_OWNER_DOES_NOT_EXIST,
						partyId)]);
				}
				return this.partyService.findByIds(contactIds);
			})
			.then((result) => {
				if (result.length !== contactIds.length) {
					return Promise.reject([new ValidationErrorImpl(
						PartyGroupServiceImpl.PARTY_ITEM,
						PartyGroupServiceImpl.PARTY_ITEM_DOES_NOT_EXIST,
						"")]);
				}
				return this.groupService.findPropertiesByType(group.type);
			}).then((result: GroupPropertiesImpl[]) => {
				const duplicatedGroup: GroupPropertiesImpl[] = result.filter(value => value.attributes[PartyGroupServiceImpl.ATTRIBUTE_PARTY_ID] === partyId);
				if (duplicatedGroup.length > 0) {
					return Promise.reject([new ValidationErrorImpl(
						PartyGroupServiceImpl.PARTY_OWNER,
						PartyGroupServiceImpl.PARTY_OWNER_DUPLICATED_GROUP,
						duplicatedGroup[0].code)]);
				}
				return this.groupService.insert(newGroup);
			}).then(() => {
				group.attributes = newGroup.attributes;
				return Promise.resolve(group);
			});
	}

	/**
	 * Updates a group and it's values.
	 * @param {Group} group The group to be updated.
	 * @return {Promise<Group>}
	 * Returns a reject if there is no group with the specified code.
	 * Returns a reject if there is an attempt to modify the owner the the group.
	 * Returns a reject if the content of the groups has duplicated values or any of the parties does not exists in the database.
	 */
	update(group: GroupImpl<PartyGroupItemImpl>): Promise<GroupImpl<PartyGroupItemImpl>> {
		this.log.debug("Call to update with group: %j", group);
		const groupToUpdate: GroupImpl<any> = _.clone(group);
		let ids = group.values.map((value) => value.party['id']);
		ids = _.uniq(ids);

		if (group.attributes[PartyGroupServiceImpl.ATTRIBUTE_PARTY_SERVICE_SIGNATURE] !== PartyGroupServiceImpl.ATTRIBUTE_VALUE_PARTY_SERVICE_SIGNATURE) {
			return Promise.reject([
				new ValidationErrorImpl(
					PartyGroupServiceImpl.ATTRIBUTE_VALUE_PARTY_SERVICE_SIGNATURE,
					PartyGroupServiceImpl.ATTRIBUTE_VALUE_PARTY_SERVICE_SIGNATURE_INVALID,
					'')
			]);
		}

		if (ids.length !== group.values.length) {
			this.log.error("Attempting to update a party group with duplicated party items");
			return Promise.reject([
				new ValidationErrorImpl(
					PartyGroupServiceImpl.PARTY_ITEM,
					PartyGroupServiceImpl.PARTY_ITEM_DUPLICATED,
					'')
			]);
		}
		return this.partyService.findByIds(ids)
			.then((resultQuery: any[]) => {
				if (resultQuery.length !== ids.length) {
					this.log.error("Attempting to update with items that does not exist in the database");
					return Promise.reject([new ValidationErrorImpl(
						PartyGroupServiceImpl.PARTY_ITEM,
						PartyGroupServiceImpl.PARTY_ITEM_DOES_NOT_EXIST,
						"")]);
				}

				return this.findOne(group.code);

			})
			.then((result: GroupImpl<InternalPartyGroupItem>) => {

				if (result.type !== group.type) {
					this.log.error("Attempting to modify type");
					return Promise.reject([new ValidationErrorImpl(
						PartyGroupServiceImpl.TYPE,
						PartyGroupServiceImpl.ATTRIBUTE_CHANGE,
						"")]);
				}

				if (result.attributes[PartyGroupServiceImpl.ATTRIBUTE_PARTY_ID] !== group.attributes[PartyGroupServiceImpl.ATTRIBUTE_PARTY_ID]) {
					this.log.error("Attempting to modify party owner");
					return Promise.reject([new ValidationErrorImpl(
						PartyGroupServiceImpl.PARTY_OWNER,
						PartyGroupServiceImpl.ATTRIBUTE_CHANGE,
						"")]);
				}

				// All validations done. Let's update the group.
				groupToUpdate.values = group.values.map(value => {
					const item = new InternalPartyGroupItem();
					item.partyId = value.party['id'];
					item.attributes = value.attributes;
					return item;
				});
				return this.groupService.update(groupToUpdate);
			})
			.then(() => {
				return Promise.resolve(group);
			});
	}

	/**
	 * Delete group.
	 * @param {Group} code
	 * @return {Promise<any>} Returns a reject if there is no group with the specified code.
	 */
	remove(code: string): Promise<any> {
		this.log.debug("Call to remove with code %j", code);
		return this.groupService.remove(code);
	}

	/**
	 * Insert an element to an existing group.
	 * @param {string} code The group code.
	 * @param item The item to insert.
	 * @return {Promise<any>} Return a Promise indicating the item is inserted.
	 * Returns a reject if the method was not able to identify a group given the code.
	 * Returns a reject if the objectToInsert exists already in the group.
	 * Return a reject if the objectToInsert is null or does not exits in the database.
	 */
	addItem(code: string, item: PartyGroupItemImpl): Promise<any> {
		this.log.debug("Call to addItem with code: %j, item: %j", code, item);
		return this.partyService.findOne(item.party['id'])
			.then((resultQuery) => {
				if (resultQuery == null) return Promise.reject([new ValidationErrorImpl(
					PartyGroupServiceImpl.PARTY_ITEM,
					PartyGroupServiceImpl.PARTY_ITEM_DOES_NOT_EXIST,
					item.party['id'])]);

				return this.groupService.findOne(code);
			})
			.then((result: GroupImpl<InternalPartyGroupItem>) => {

				if (result == null) return Promise.reject(GroupServiceValidator.NO_GROUP);

				const duplicated = result.values.filter(value => value.partyId === item.party['id']);
				if (duplicated.length > 0) {
					this.log.error("Attempting to add a duplicated party item ( %j ) to group %j", item, code);
					return Promise.reject([
						new ValidationErrorImpl(
							PartyGroupServiceImpl.PARTY_ITEM,
							PartyGroupServiceImpl.PARTY_ITEM_DUPLICATED,
							item.party['id'])
					]);
				}

				const itemToAdd: InternalPartyGroupItem = new InternalPartyGroupItem();
				itemToAdd.partyId = item.party['id'];
				itemToAdd.attributes = item.attributes;
				return this.groupService.addItem(code, itemToAdd);
			});

	}

	/**
	 * Inserts a new party (using PartyService) and add the inserted party to the group.
	 * @param {string} code The group to insert the new party.
	 * @param {PartyAbstract} party The party to insert.
	 * @param attributes attributes to insert.
	 * @returns {Bluebird<PartyAbstract>} Returns the inserted party.
	 * The methods return a error if there is no group with the same code.
	 * This method returns the same errors of PartyService.insert or the same errors of
	 * PartyGroupItemService.addItem
	 */
	addItemNewParty(code: string, party: PartyAbstract, attributes: { [p: string]: string }): Promise<PartyAbstract> {
		this.log.debug("Call to addItemNewParty with code: %j, party: %j, attributes: %j", code, party, attributes);
		let insertedParty: PartyAbstract;

		return this.groupService.findOne(code)
			.then((result) => {
				if (result == null) return Promise.reject(GroupServiceValidator.NO_GROUP);
				return this.partyService.insert(party);
			})
			.then((result: PartyAbstract) => {
				insertedParty = result;
				const partyGroupItem: PartyGroupItemImpl = new PartyGroupItemImpl();
				partyGroupItem.attributes = attributes;
				partyGroupItem.party = result;
				return this.addItem(code, partyGroupItem);
			})
			.then(() => {
				return Promise.resolve(insertedParty);
			});
	}

	/**
	 * Removes an item of the group.
	 * @param {string} code.
	 * @param partyId The id of object to remove.
	 * Return a Promise if the remove was successful.
	 * Returns a reject if there is no group given the code.
	 * Returns a reject if the object to remove is null or undefined.
	 */
	removeItem(code: string, partyId: string): Promise<any> {
		this.log.debug("Call to removeItem with code:%j , partyId: %j", code, partyId);
		return this.groupService.findOne(code)
			.then((group: GroupImpl<InternalPartyGroupItem>) => {
				if (group == null) return Promise.reject(GroupServiceValidator.NO_GROUP);
				const founded = group.values.filter(value => value.partyId === partyId);
				if (founded.length === 0) {
					this.log.error("Attempting to remove an item that does not exists in ( %j ) to group %j", partyId, code);
					return Promise.reject([
						new ValidationErrorImpl(
							PartyGroupServiceImpl.PARTY_ITEM,
							PartyGroupServiceImpl.PARTY_ITEM_DOES_NOT_EXIST,
							partyId)
					]);
				} else {
					return this.groupService.removeItem(code, founded[0]);
				}
			});
	}

	/**
	 * Validate the party groups.
	 * @param {GroupImpl<PartyGroupItemImpl>} group
	 */
	private validatePartyGroup(group: GroupImpl<PartyGroupItemImpl>): ValidationErrorImpl[] {
		const errors: ValidationErrorImpl[] = [];
		const groupedValues = _.groupBy(group.values, (o) => o.party['id']);
		for (const key in groupedValues) {
			if (groupedValues[key].length > 1) {
				errors.push(new ValidationErrorImpl(PartyGroupServiceImpl.PARTY_ITEM, PartyGroupServiceImpl.PARTY_ITEM_DUPLICATED, key));
			}
		}
		return errors;
	}

	private mapData(referenceGroups: Array<GroupImpl<InternalPartyGroupItem>>): Promise<Array<GroupImpl<PartyGroupItemImpl>>> {
		let ids: string[] = [];
		for (const group of referenceGroups) {
			ids = ids.concat(group.values.map(value => value.partyId));
		}
		ids = _.uniq(ids);
		return this.partyService.findByIds(ids)
			.then((resultQuery: PartyAbstract[]) => {
				let resultGroup: any[];
				resultGroup = referenceGroups.map(value => {
					const item: any = value;
					item.values = value.values.map(value2 => {
						const item2: PartyGroupItemImpl = new PartyGroupItemImpl();
						item2.party = _.find(resultQuery, (o) => o['id'] === value2.partyId);
						item2.attributes = value.attributes;
						return item2;
					});
					return item;
				});
				return Promise.resolve(resultGroup);
			});
	}
}
